# Solution Report
This report summarizes my implementation of the 5 assignments within the robot lab of CSE2425 Embedded Systems course.

## Assignment 1: Variable Speed
> Control the motors using PWM signals and timers. The program should start the robot and make it run, after 3-4 sec at condtant speed, increase the duty cycle to make it run faaster and after 3-4 more seconds slow down the robot gradually and make it stop

> Passing Criteria: 1.5pts if using timer registers.

For this first assignment, I started of by figuring out what the passingcriteria meant by timer registers. So after setting the motors to run at some duty cycle,I need to wait some amount of seconds, and I need to do that in a busy wait loop thats dictated by these timer registers, which I found to be in the pico SDK ```hardware/structs/timer.h```. Based on that, I made the file [timers.c](./snapshots/assignment1_pwm/src/timers.c), which accesses the ```timer_hw->timerawl``` register to count microseconds and expose the ```busy_wait_ms_hw(uint32_t ms)``` function.  
After that, I moved onto actually implementing the PWM functionality for the motors. I put all of that in [motors_pwm.c](./snapshots/assignment1_pwm/src/motors_pwm.c). I first started my experiments by simply driving the pins high with simple SIO, to figure out which combinations are for forward and reverse for each motor and defined those at the top of the file. Then I set up my PWM config. I decided to use a PWM frequency of 20KHz, which given the system clock of 125MHz and choosing a PWM clock divider of 1.0, gives us a TOP value of 6249.  
After that, I made some helper functions for configuring the IO and getting the PWm slices and channels:
- ```gpio_set_func_pwm(uint gpio)``` - takes a GPIO pin number and sets its control register to PWM function
- ```pwm_slice_for_gpio(uint gpio)``` - returns the PWM slice number for a GPIO pin number, which given the 8 slices with 2 channels each is equal to  ```(gpio % 16) / 2```
- ```pwm_chan_is_b(uint gpio)``` - returns true if the GPIO pin number corresponds to a B channel. which is equivalent to checking if pin number is odd.
- ```pwm_init_slice(uint slice)``` - takes a slice number and initializes it for PWM. Sets the control, div, top, cc registers.
I also made some more helper functions which take a duty_percent between \[0,100\], and transforms that to the actual PWM CC level it would mean. Also made a helper to apply a level to the CC register of a corresponding GPIO pin number, and with that I expose 4 public functions that can be used, along with some nice structs for selecting direction and motor:
- ```motors_pwm_init()```
- ```motors_pwm_stop(motor_select_t which)```
- ```motors_pwm_drive(motor_select_t which, motor_dir_t dir, uint8_t duty_percent)```
- ```motors_pwm_drive_lr(motor_dir_t left_dir, uint8_t left_duty, motor_dir_t right_dir, uint8_t right_duty)```

With all these functions implemented, making [main.c](./snapshots/assignment1_pwm/src/main.c) is trivial. I initialize the motors, droive them at a set speed, wait 3 seconds, increase speed, wait another 3 seconds, then stop gradually.

## Assignment 2: Obstacle detection and stopping
> Use the front ultrasonic ranging sensor to detect an obstacle in front of the robot. Your program should make the robot run forward, detect if there is an obstacle ahead, stop when it comes close to the obstacle.

> Passing Criteria: 2.5pts if using PIO

For this assignment, I will go into less detail about the code than I did for the previous one, otherwise this report will become way too long.

So I wanted to use PIO for this assignment to get the max points. I found in some public repo on github a similar implementation to what I needed that did exactly PIO on a HCSR04 sensor, so I used that as an example and implemented it. But the way this first iteration worked, is it set up the PIO code to do a 10us rise on the TRIG pin, then wait for the ECHO pin and send back in the FIFO how many cycles the ECHO pin was high. And then in the C code, they would have a function which would clear the FIFO's to trogger a new measurment, and then busy wait until the first value appeared in the FIFO, then did some math to convert those cycles to cm and return that. And this worked fine, but it is still the main CPU polling the sensor and busy waiting for the answer every time in a loop. Which felt redundant to me, as in why would we even use PIO if we end up doing polling and waiting anyway.  
With that in mind, I decided to comlicate my life a bit and do this assignment a bit differently. To keep a state machine directly in PIO, and within PIO, only ever trigger an interrupt whenevr the state changes. So to do this, first of all I separated my PIO code into 2 programs, one for the trig loop and one for the ECHO loop, both running on a 2 MHz clock.  
The TRIG program, ets the TRIG pin high for 20 cycles, which would mean 10 microseconds, then waits for 60 miliseconds and then repeats.  
The ECHO program holds the corrent robot state in the X register (0 = standing still, 1 = moving). Also, the program uses hysteresis so I have different thrwesholds for stopping and for going, so there is no flicker at exactly 15cm. With that, the program starts by pulling the 2 threshodls from the FIFO into the isr and osr registers. and sets the initial state to 0. It then waits for the EXHO pin to go high, and based on the current state, we load the corrsponding threshold into the y register, do nothing for like 30 cycles (to counteract very short ECHO bursts that happen for like very long distances, idk, it s like a bug of the sensor), and then while the pin is high, keep decrementing Y. If the pin goes low while the Y register hasnt hit 0 yet, it means the distance measured is smaller than the thresholds, so based on the state, if we are currently moving, we raise irq 0 to stop. otherwise if we were stopped anyway we do nothing. If the Y register hits 0 before the pin goes low, it means the distance measured is bigger than the threshold, so based on the state, if we were currently standing till, we raise irq 1 to start moving. if we were already moving we do nothing.  
This approach puts all the computation on the PIO and it feels like it maximizes the potential of PIO. The CPU does not have to poll for distance ever, it only ever gets an interrupt whenit should stop or when it should go.

Some problems I encountered with this approach was that my 2 programs were both under 32 lines of PIO instructions, but together they went over. So because each program individually was under 32 instructions they would compile, but I was trying to load them on the same PIO instance, on different state machines, and because together they exceeded the memory limit, my program would fail very weirdly. I realized this was the problem, and loaded the 2 programs on the 2 different PIO instances and then it worked miraculously. Afterwards, I optimized the code so both programs would fit on a single PIO instance.

Apart from the PIO code, setting up the actual state machines in ```HCSR04.c``` and such was not that complicated, I just followed the examples in the datasheet, set the clock div to something convenient so my math worked out, initialized the configs, the in pins, the jmp pins and all that stuff, (put a pulldown on the echo pin, which helped with some bugs I had where it was floating between values), set up the irq handlers, and initialized the state machines.  
Then in the actual ```main.c```, all i had to do was set implementations for the ir handlers and call the functions to initialize the motors and sensors.

## Assignment 3: Line Follower
> The robot should follow a black line on the floor, including any curves, using the 2 TCRT5000 sensors on the bottom of the robot.

> Passing Criteris: 2pts if using ADC with registers

So for this assignment, I started off by making the ```TCRT5000.c``` file, which would take care of initializing and running the sensor and stuff and then exposing 2 functions to read the values of the 2 sensors. So the 2 sensors had their analog channels plugged into the 26 and 27 GPIO pins, which conevninatly are the ADC channels 0 and 1.  
So to initialize the pins to work on ADC, I start off by setting the io bank controll regiser to null, and then also amking sure there is no pullup or pulldown or input enable in the pads bank. With these functions turned off, the signal can freely go to the adc controller.  
Then, to read an ADC channel, I start by reseting the channel select with the enable bits and the start once bits, which initializes a new measurement, then busy wait until the channel select ready bits are on, at which point we can read the result register.  

That was using ADC to actually read the sensor values, which for me was the simpler part of this assignment. Getting the line follower to work was much harder, and there are 2 clear reasons why:
- The DC motors are terrible, in my case, the robot only ever moves if the PWM duty cycle is between \[70,100\], which gives me a very narrow window of actually usefull motor inputs.
- The TCRT5000 sensors are mounted WAYYY too close to the wheels, which does not give the roboto enough time to take a wide turn, so in order to not lose the line by the time you actually stop the robots inertia, you have to jerk the inner wheel backwards to turn the robot in time, which poses a whole different set of challenges.  
My Biggest 2 pieces of feedback for this lab would be to buy new/better motors (or switch to brushless if we have the encoders anyway) and to change the assembly to move the infrared sensors wayyy in front of the robot body (like proper line followers do).

Anyway, to actually get stareted on the line follower code, I decided to use a simple PID controller, so i implemented a PID interface in ```pid.c``` with integral and output gating, and simple one step derivative calculation. and then I implemented said interface in ```line_follow.c```. However, this is where my problems began. to have the robotactually move forward at a decent speed, I had to set my base speed to smth like 80% duty cycle, which then gives the output of my PID a min max of +- 20, so the new max speed would be 100% duty cycle, but then the min speed would be only 60% (which given the terrible motors means the wheeel would stand still).  
Also, for this assignment, I extended my motor interface to accept signed inputs, anything between \[-100,100\], but also made it so any input in the deadzone of \[-65,65\] gets set to thos minimu duties.  
And as I said earlier, having the sensors so close to the wheels, and the robot having it s inertia, in order to be able to take a 90 degree turn efficiently, I had to find a way to turm in-place, which meant jerking the inner wheel backwards. I had 2 choices on how to do that, I started off by not gating the PID output, letting it have a min max of +- 180, which at max output on the inner wheel would drive it at -100, which kinda worked, but then, the outer wheel was like always at 100% and to get this to work, I had to crank the KP wayy up into the hundreds, which then felt like we are not even using the PID controller properly anymore. My second option, which I ended up going with was to leave the PID output gated at +- 20 but have a multiplicative factor on the inner wheel correction. This solution allowed the outer wheel to actually osciallate correctly between it s base speed and max speed, and also the inner wheel to be able to go into the negatives and drive backwards. So conceptually this felt like a better solution, but then, it still didnt work reliably on a 90 degree turn until I cranked the KP up into the 150-200 range, which again just meant the PID output was basically always maximal. This made the robot good in the corners, but very jittery and slow on straights. But oh well, as long as it works I guess.

Again, this could have worked out so much better if the infrared sensors were mounted more towards the front of the robot.

## Assignment 4: Obstacle avoidance
> Follow a straight line, detect if there is an object, navigate around it

> Passing criteria 2.5pts if using multicore with registers.

For this assignment, I started by reverting my PIO code to a dumber version, which only ever pushes us counts to the FIFO, and then you can poll for these counts in the C code and then calculate the cm distance.

In order to get the multicore points, I have the state machine that switches between line following and obstacle avoidance on core 0, and then core 1 continuously polles the fornt sensor for measurements, and when it gets a measurmeent under a thresholds, it pushes a value to the inter-core FIFO, which causes core 0 to swicth states.  
I first implemented multi core using the SDK methods and then simply went into the SDK documentation and copied and simplified the implementations of thos methods and put them in ```multicore.c```.

For the actual obstacle avoidance stuff, I tried a bunch of different methods to get it to work. I tried to have it be more experiment driven, where Ijust drive the motors to turn in place for a certain amount of time, and then drive forward for a certain amount of time and so on until I clear the obstacle, and adjust those times by trial and error, but this implementation fails on different floor materials, as the grip differs and sometimes the wheels slip, sometimes i need more power to turn, etc. I also tried to do the same thing, but more sensor-driven: read the front sensor, turn in place until the side sensor reads the same as teh fornt sensor, go forward until the side sensor has a big jump in numbers (which means you got to the end of the box), turn left estimated 90 degrees, go forward until side sensor sees the box again, and so on...; There were multiple problems with this approach: because of the line foollowing code, when I first come up to the obstacle, i might not be in a perfect 90 degrees to the betacle, when I reach a corner of the obstacle, I am in a sensor blackout, the side sensor cant see anythong, the front sensor cant see anything, so i heav to guess where to go.  
I then had the idea to just put a PID controller on the side snesor and tell it to just keep the distance the same. so that the robot can autonomously follow the side of an obstacle. This idea first orginated in my intial sensor-driven approach , but initially I only let this PID thing go on trhe straight portion of the obstacle, and then kill it when the side sensor detects a jump in it s measurments. but then I noticed that at the corner of the object, the robot eith the PID thing was trying to turn by itself. So I then realised that I could just let the PID thing try to follow the obstacle the whole way around instead of killing it early. So I did that, but it would lose the box at the corners. Problem was that the side sensor is behind the wheels. So if it detects that it is too far away, it tires to turn to the left (my sensor is on the left of the robot), but with the sensor being behind the wheels, that pushes it evenfurther away. so it s a negative feedback loop back into the PID, which is causing it to fail. I then decided to just move the side sensor and reinstalled it in the front of the robot, still pointing to the side. After this assemblky change, my robot was able to perfectly avoid the obstacle (and any obstacle of any size) using only the side-hold PID thing. The stopping condition for this is if the infrared sensors detect the line on the otehr side of the obstacle.

## Assignment 5: 
> Use the speed encoders to have the robot travel a fixed distance on a line.

> Passing criteria: 2pts if error < 10cm and using registers

For this assignment, I started off by relaxing the KP and removing the inside-wheel mnultiplicative corrwction factor in my line_follower code, as we don t have to take any turns in this assignment, and these changes would allow a smoother straigh-line drive.

To actually imolement the speed encoders, I counted the number of slits (20) and the diameter of the wheel (65mm). I set the pins of the encoders to simple SIO, and set it up so that on a rising edge of one of these pins, an interrput is triggered which does some debouncing logic and if the debounce was ok, it imncrements a counter variable. I then have public methods to initialize, read and reset those counts. In ```main.c```, i made a function that uses that wheel diameter to transofrm those tick counts into mms traveled, and I simply use the line follower step until the distance travelesd is close to my set threshold. I intentioanlly give the robot the stop command 30mm before the actual goal, in order to counteract the inertia of stopping.

I also use the ecnoder code a bit in assignment 4 for turnning a fixed distance. as using the ticks for a turn distance measurmenet is more raliable than just using a timer.